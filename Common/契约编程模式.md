## ğŸ¯ å¥‘çº¦ç¼–ç¨‹æ¨¡å¼çš„å®Œæ•´å®ç°æ­¥éª¤ (ä»¥Orchestrator/HyperloopServerä¸ºä¾‹

### ğŸ“ **æ­¥éª¤ 1ï¼šç¼–å†™ OpenAPI è§„èŒƒæ–‡ä»¶**

æ–‡ä»¶ä½ç½®ï¼š`spec/openapi-hyperloop.yml`

```yaml
openapi: 3.0.0
info:
  version: 0.1.0
  title: E2B Hyperloop

paths:
  /me:
    get:
      operationId: me        # â† å®šä¹‰æ“ä½œIDï¼Œç”Ÿæˆ Me() æ–¹æ³•
      description: Returns information about sandbox itself
      responses:
        "200":
          content:
            application/json:
              schema:
                $ref: "#/components/schemas/Me"

  /logs:
    post:
      operationId: logs      # â† å®šä¹‰æ“ä½œIDï¼Œç”Ÿæˆ Logs() æ–¹æ³•
      description: Receives JSON based logs messages
      responses:
        "200":
          description: Request was successful

components:
  schemas:
    Me:                      # â† å®šä¹‰æ•°æ®æ¨¡å‹
      required:
        - sandboxID
      properties:
        sandboxID:
          type: string
```

---

### âš™ï¸ **æ­¥éª¤ 2ï¼šé…ç½®ä»£ç ç”Ÿæˆå·¥å…·**

æ–‡ä»¶ä½ç½®ï¼š`packages/orchestrator/Makefile`

```8:20:packages/orchestrator/Makefile
openapi := ../../spec/openapi-hyperloop.yml
codegen := go tool github.com/oapi-codegen/oapi-codegen/v2/cmd/oapi-codegen

.PHONY: generate
generate:
    @echo "Generating..."
    docker build -t proto-gen -f generate.Dockerfile .
    docker run --rm -v .:/workspace -v ./../shared/pkg/grpc:/shared/pkg/grpc proto-gen
    @echo "Generating hyperloop api..."
    // ç”Ÿæˆ Gin æœåŠ¡å™¨æ¥å£å’Œè·¯ç”±ç»‘å®šä»£ç 
    $(codegen) -old-config-style -generate gin --package api $(openapi) > ../shared/pkg/http/hyperloop/api.gen.go
    // ç”Ÿæˆ Go ç»“æ„ä½“ï¼ˆå¯¹åº” OpenAPI çš„ schemasï¼‰
    $(codegen) -old-config-style -generate types --package api $(openapi) > ../shared/pkg/http/hyperloop/types.gen.go
    // ç”ŸæˆåµŒå…¥å¼ OpenAPI è§„èŒƒï¼ˆç”¨äºè¿è¡Œæ—¶éªŒè¯ï¼‰
    $(codegen) -old-config-style -generate spec --package api $(openapi) > ../shared/pkg/http/hyperloop/spec.gen.go
    @echo "Done"
```

---

### ğŸ—ï¸ **æ­¥éª¤ 3ï¼šè¿è¡Œä»£ç ç”Ÿæˆ**

```bash
# åœ¨é¡¹ç›®æ ¹ç›®å½•è¿è¡Œ
make generate/orchestrator

# æˆ–è€…ç›´æ¥åœ¨ orchestrator ç›®å½•
cd packages/orchestrator
make generate
```

è¿™ä¼šç”Ÿæˆä¸‰ä¸ªæ–‡ä»¶ï¼š

#### **3.1.1 ç”Ÿæˆçš„æ¥å£å®šä¹‰** - `api.gen.go`

```10:18:packages/shared/pkg/http/hyperloop/api.gen.go
// ServerInterface represents all server handlers.
type ServerInterface interface {

    // (POST /logs)
    Logs(c *gin.Context)

    // (GET /me)
    Me(c *gin.Context)
}
```

#### **3.1.2 ç”Ÿæˆçš„è·¯ç”±æ³¨å†Œå‡½æ•°** - `api.gen.go`

```68:84:packages/shared/pkg/http/hyperloop/api.gen.go
func RegisterHandlersWithOptions(router gin.IRouter, si ServerInterface, options GinServerOptions) {
    errorHandler := options.ErrorHandler
    if errorHandler == nil {
        errorHandler = func(c *gin.Context, err error, statusCode int) {
            c.JSON(statusCode, gin.H{"msg": err.Error()})
        }
    }

    wrapper := ServerInterfaceWrapper{
        Handler:            si,
        HandlerMiddlewares: options.Middlewares,
        ErrorHandler:       errorHandler,
    }

    router.POST(options.BaseURL+"/logs", wrapper.Logs)
    router.GET(options.BaseURL+"/me", wrapper.Me)
}
```

#### **3.2 ç”Ÿæˆçš„ç±»å‹å®šä¹‰** - `types.gen.go`

```6:19:packages/shared/pkg/http/hyperloop/types.gen.go
// Error defines model for Error.
type Error struct {
    // Code Error code
    Code int32 `json:"code"`

    // Message Error
    Message string `json:"message"`
}

// Me defines model for Me.
type Me struct {
    // SandboxID Sandbox ID
    SandboxID string `json:"sandboxID"`
}
```

#### 3.3 ç”Ÿæˆæ ¡éªŒ spec.gen.go

[spec.gen.go]: ###spec.gen.go

---

### ğŸ’» **æ­¥éª¤ 4ï¼šå®ç°æ¥å£**

åˆ›å»ºä¸€ä¸ªå®ç° `ServerInterface` çš„ç»“æ„ä½“ï¼š

#### **4.1 å®šä¹‰ Store** - `handlers/store.go`

```19:36:packages/orchestrator/internal/hyperloopserver/handlers/store.go
type APIStore struct {
    logger    *zap.Logger
    sandboxes *sandbox.Map

    collectorClient http.Client
    collectorAddr   string
}

func NewHyperloopStore(logger *zap.Logger, sandboxes *sandbox.Map, sandboxCollectorAddr string) *APIStore {
    return &APIStore{
        logger:    logger,
        sandboxes: sandboxes,

        collectorAddr: sandboxCollectorAddr,
        collectorClient: http.Client{
            Timeout: CollectorExporterTimeout,
        },
    }
}
```

#### **4.2 å®ç° Me() æ–¹æ³•** - `handlers/me.go`

```12:22:packages/orchestrator/internal/hyperloopserver/handlers/me.go
func (h *APIStore) Me(c *gin.Context) {
    sbx, err := h.findSandbox(c)
    if err != nil {
        h.sendAPIStoreError(c, http.StatusBadRequest, "Error when finding source sandbox")
        h.logger.Error("error finding sandbox for source addr", zap.String("addr", c.Request.RemoteAddr), zap.Error(err))

        return
    }

    c.JSON(http.StatusOK, &api.Me{SandboxID: sbx.Runtime.SandboxID})
}
```

#### **4.3 å®ç° Logs() æ–¹æ³•** - `handlers/logs.go`

```14:22:packages/orchestrator/internal/hyperloopserver/handlers/logs.go
func (h *APIStore) Logs(c *gin.Context) {
    sbx, err := h.findSandbox(c)
    if err != nil {
        h.sendAPIStoreError(c, http.StatusBadRequest, "Error when finding source sandbox")
        h.logger.Error("error finding sandbox for source addr", zap.String("addr", c.Request.RemoteAddr), zap.Error(err))

        return
    }

    sbxID := sbx.Runtime.SandboxID
```

---

### ğŸš€ **æ­¥éª¤ 5ï¼šç»„è£…æœåŠ¡å™¨**

åœ¨ `server.go` ä¸­æŠŠæ‰€æœ‰éƒ¨åˆ†è¿æ¥èµ·æ¥ï¼š

```22:46:packages/orchestrator/internal/hyperloopserver/server.go
func NewHyperloopServer(ctx context.Context, port uint16, logger *zap.Logger, sandboxes *sandbox.Map) (*http.Server, error) {
    sandboxCollectorAddr := env.LogsCollectorAddress()
    store := handlers.NewHyperloopStore(logger, sandboxes, sandboxCollectorAddr)
    swagger, err := api.GetSwagger()
    if err != nil {
        return nil, fmt.Errorf("error getting swagger spec: %w", err)
    }

    engine := gin.New()
    engine.Use(
        gin.Recovery(),
        limits.RequestSizeLimiter(maxUploadLimit),
        middleware.OapiRequestValidatorWithOptions(swagger, &middleware.Options{}),
    )

    server := &http.Server{
        Handler: engine,
        Addr:    fmt.Sprintf("0.0.0.0:%d", port),

        BaseContext: func(net.Listener) context.Context { return ctx },
    }

    api.RegisterHandlersWithOptions(engine, store, api.GinServerOptions{})

    return server, nil
}
```

### spec.gen.go

åœ¨è¿è¡Œæ—¶å¯ä»¥ä½¿ç”¨å®ƒè¿›è¡Œè¯·æ±‚éªŒè¯ã€‚

```18:29:packages/shared/pkg/http/hyperloop/spec.gen.go
// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

    "H4sIAAAAAAAC/7xTwY7TMBD9FWvgGDWhC5ccV7sSRRQkekR7cJ1J1ijxmBmnsKry72icQLW0hQsiF9uZ",
    "mTfznp+P4GiIFDAkgfoIjBIpCObD66rSxVFIGJJubYy9dzZ5CuUXoaD/xD3iYHX3krGFGl6UJ8xyjkp5",
    "z0wM0zQV0KA49lFBoIZb2xjGryNKgqmAN/+j5w75gGxwiRcLXiY9F9VHiEwROflZC0cN6vocKCebHCug",
    "JR5sghp8SDdrKCA9RZyP2CEruwFFbHcN6FQiiX3o8miqjWdsoP4MS6OfKA9TAVs8n1VsaPb0fXN33mc3",
    "h8zm7q/NTigPWUIfWlLA5FOvZffrW/P2KSL3RBEKOCDL3KRavVpVSpciBhs91HCzqlYVFBBteswzlj11",
    "eRNJ0vmcn9ChP6CYd7uPH8zeCjZGK8zCXSCjc7bFpoEa3ite8dzA69lMv0Nns5lvVoyMzqFIO/Y67uL3",
    "S5b6BVtq0smnf87VpCmLVw75njq8yDWNHMSowOogT8HYPY3JLFdgfBLs2zPKW7xC+J+8ni1eejrX1Mvf",
    "jwAAAP//DgfnLk4EAAA=",
}
```

çœ‹åˆ°äº†å—ï¼Ÿè¿™æ˜¯ä¸€ä¸ª**Base64 ç¼–ç  + Gzip å‹ç¼©**çš„ OpenAPI è§„èŒƒï¼

### ğŸ” ä¸ºä»€ä¹ˆè¦è¿™æ ·åšï¼Ÿ

```71:101:packages/shared/pkg/http/hyperloop/spec.gen.go
// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
    resolvePath := PathToRawSpec("")

    loader := openapi3.NewLoader()
    loader.IsExternalRefsAllowed = true
    loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
        pathToFile := url.String()
        pathToFile = path.Clean(pathToFile)
        getSpec, ok := resolvePath[pathToFile]
        if !ok {
            err1 := fmt.Errorf("path not found: %s", pathToFile)
            return nil, err1
        }
        return getSpec()
    }
    var specData []byte
    specData, err = rawSpec()
    if err != nil {
        return
    }
    swagger, err = loader.LoadFromData(specData)
    if err != nil {
        return
    }
    return
}
```

`GetSwagger()` å‡½æ•°ä¼šï¼š

1. è§£ç  Base64 å­—ç¬¦ä¸²
2. è§£å‹ Gzip æ•°æ®
3. è¿”å›å®Œæ•´çš„ OpenAPI è§„èŒƒå¯¹è±¡

### ğŸ¯ åœ¨å“ªé‡Œä½¿ç”¨ï¼Ÿ

å›åˆ° `server.go`ï¼Œçœ‹ç¬¬ 25 è¡Œï¼š

```22:35:packages/orchestrator/internal/hyperloopserver/server.go
func NewHyperloopServer(ctx context.Context, port uint16, logger *zap.Logger, sandboxes *sandbox.Map) (*http.Server, error) {
    sandboxCollectorAddr := env.LogsCollectorAddress()
    store := handlers.NewHyperloopStore(logger, sandboxes, sandboxCollectorAddr)
    swagger, err := api.GetSwagger()
    if err != nil {
        return nil, fmt.Errorf("error getting swagger spec: %w", err)
    }

    engine := gin.New()
    engine.Use(
        gin.Recovery(),
        limits.RequestSizeLimiter(maxUploadLimit),
        middleware.OapiRequestValidatorWithOptions(swagger, &middleware.Options{}),
    )
```

**ç¬¬ 25 è¡Œ**ï¼šè°ƒç”¨ `api.GetSwagger()` è·å– OpenAPI è§„èŒƒ
**ç¬¬ 34 è¡Œ**ï¼šæŠŠè§„èŒƒä¼ ç»™éªŒè¯ä¸­é—´ä»¶ `OapiRequestValidatorWithOptions`

### âœ… è¿è¡Œæ—¶éªŒè¯

è¿™ä¸ªä¸­é—´ä»¶ä¼šåœ¨æ¯ä¸ªè¯·æ±‚åˆ°è¾¾ä½ çš„ handler ä¹‹å‰ï¼Œè‡ªåŠ¨éªŒè¯ï¼š

1. **è·¯å¾„å‚æ•°**ï¼šæ˜¯å¦ç¬¦åˆå®šä¹‰çš„æ ¼å¼
2. **æŸ¥è¯¢å‚æ•°**ï¼šç±»å‹ã€å¿…å¡«æ€§
3. **è¯·æ±‚ä½“**ï¼šJSON ç»“æ„æ˜¯å¦åŒ¹é… schema
4. **Content-Type**ï¼šæ˜¯å¦æ­£ç¡®
5. **å¿…å¡«å­—æ®µ**ï¼šæ˜¯å¦éƒ½å­˜åœ¨

å¦‚æœéªŒè¯å¤±è´¥ï¼Œè¯·æ±‚ä¼šè¢«è‡ªåŠ¨æ‹’ç»ï¼Œè¿”å› 400 é”™è¯¯ï¼Œ**ä½ çš„ handler ä»£ç æ ¹æœ¬ä¸ä¼šæ‰§è¡Œ**ï¼

### ğŸ“¦ ä¸ºä»€ä¹ˆè¦åµŒå…¥è€Œä¸æ˜¯è¯»æ–‡ä»¶ï¼Ÿ

å¯¹æ¯”ä¸¤ç§æ–¹æ¡ˆï¼š

#### âŒ æ–¹æ¡ˆ Aï¼šè¿è¡Œæ—¶è¯»å–æ–‡ä»¶

```go
// éœ€è¦åœ¨éƒ¨ç½²æ—¶æºå¸¦ YAML æ–‡ä»¶
swagger, err := openapi3.NewLoader().LoadFromFile("spec/openapi-hyperloop.yml")
```

**ç¼ºç‚¹**ï¼š

- éœ€è¦åœ¨ç”Ÿäº§ç¯å¢ƒéƒ¨ç½² YAML æ–‡ä»¶
- æ–‡ä»¶è·¯å¾„å¯èƒ½å‡ºé”™
- å¢åŠ  I/O æ“ä½œ

#### âœ… æ–¹æ¡ˆ Bï¼šåµŒå…¥åˆ°ä»£ç ï¼ˆå½“å‰æ–¹æ¡ˆï¼‰

```go
// OpenAPI è§„èŒƒç›´æ¥ç¼–è¯‘åˆ°äºŒè¿›åˆ¶æ–‡ä»¶ä¸­
swagger, err := api.GetSwagger()
```

**ä¼˜ç‚¹**ï¼š

- âœ¨ **å•ä¸ªäºŒè¿›åˆ¶æ–‡ä»¶**ï¼šæ‰€æœ‰ä¸œè¥¿éƒ½æ‰“åŒ…åœ¨ä¸€èµ·
- ğŸš€ **æ›´å¿«**ï¼šä¸éœ€è¦è¯»æ–‡ä»¶ï¼Œç›´æ¥ä»å†…å­˜è§£ç 
- ğŸ”’ **ç‰ˆæœ¬ä¸€è‡´**ï¼šä»£ç å’Œè§„èŒƒæ°¸è¿œåŒ¹é…ï¼Œä¸ä¼šå‡ºç°æ–‡ä»¶ç‰ˆæœ¬ä¸ä¸€è‡´
- ğŸ“¦ **éƒ¨ç½²ç®€å•**ï¼šåªéœ€è¦éƒ¨ç½²ä¸€ä¸ªå¯æ‰§è¡Œæ–‡ä»¶

### ğŸ é¢å¤–å¥½å¤„

è¿™ç§æ–¹å¼è¿˜æœ‰ä¸€ä¸ªéšè—å¥½å¤„ï¼šä½ å¯ä»¥é€šè¿‡ API æš´éœ²è§„èŒƒæœ¬èº«ï¼

```go
// å¾ˆå¤šé¡¹ç›®ä¼šæ·»åŠ è¿™æ ·çš„ç«¯ç‚¹
router.GET("/openapi.json", func(c *gin.Context) {
    swagger, _ := api.GetSwagger()
    c.JSON(200, swagger)
})
```

ç”¨æˆ·è®¿é—® `/openapi.json` å°±èƒ½çœ‹åˆ°å®Œæ•´çš„ API æ–‡æ¡£ï¼Œå¯ä»¥ç”¨ Swagger UI ç­‰å·¥å…·å±•ç¤ºã€‚
