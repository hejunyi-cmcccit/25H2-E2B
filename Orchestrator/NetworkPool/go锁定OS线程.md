## 🔒 锁定 OS 线程

### 为什么需要锁定线程？

Go 的 goroutine 可能在任何时候被调度器迁移到不同的 OS 线程上执行。但网络命名空间是**线程级别**的属性，每个线程有自己的网络命名空间。

**类比：**
- **不锁定**：你在 A 房间开始做实验，中途可能被传送到 B 房间，但你的实验器材还在 A 房间
- **锁定**：你和你的实验器材始终在同一个房间

**问题示例：**

```go
hostNS, err := netns.Get()           // 在线程1获取命名空间
// 如果不锁定，下面的代码可能在线程2执行
ns, err := netns.NewNamed(...)       // 在线程2创建命名空间 ❌
err = netns.Set(ns)                  // 设置线程2的命名空间，但线程1不知道 ❌
```

**正确做法：**

```go
runtime.LockOSThread()       // 告诉 Go：这个 goroutine 必须一直在这个线程上
defer runtime.UnlockOSThread()  // 函数结束后解除绑定
```

---

## 
